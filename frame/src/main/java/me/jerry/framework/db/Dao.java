package me.jerry.framework.db;import android.content.ContentValues;import android.content.Context;import android.database.Cursor;import android.database.sqlite.SQLiteDatabase;import java.io.File;import java.io.IOException;import java.lang.reflect.Field;import java.util.ArrayList;import java.util.List;import me.jerry.framework.utils.StringUtils;/** * 通用数据库操作实例 * @author JerryGeng * @param <T> 表类型 */public class Dao<T extends TableEntity> implements IDao<T> {    private SQLiteDatabase database;    private Class<? extends TableEntity> dataClass;    private Context context;    private OnDatabaseUpdateListener listener;    public Dao(Class<? extends TableEntity> dataClass, Context context, OnDatabaseUpdateListener listener) {        this.dataClass = dataClass;        this.context = context;        this.listener = listener;        getDb();    }    /**     * insert a row.     * We will check if the column is nullable. If the column is not nullable and the data is null, we will throw a SqlException.     * @param data     * @return     * @throws SqlException     */    @Override    public int insertData(T data) throws SqlException {        ContentValues cv = new ContentValues();        Field[] fields = data.getClass().getDeclaredFields();        try {            for(Field field : fields) {                Column column = field.getAnnotation(Column.class);                if(column != null) {                    field.setAccessible(true);                    if(field.get(data) == null) {                        if(!field.getName().equals("id")) {                            if(!column.nullable()) {                                throw new SqlException(dataClass.getName() + " -> " + field.getName() + " can not be null");                            }                            cv.putNull(StringUtils.upTo_(field.getName()));                        }                    } else {                        if(field.getType() == Integer.class || field.getType() == Short.class || field.getType() == Long.class) {                            cv.put(StringUtils.upTo_(field.getName()), Long.valueOf(((Number)field.get(data)).longValue()));                        } else if(field.getType() == String.class) {                            cv.put(StringUtils.upTo_(field.getName()), (String)field.get(data));                        } else if(field.getType() == byte[].class) {                            cv.put(StringUtils.upTo_(field.getName()), (byte[])field.get(data));                        } else if(field.getType() == Float.class || field.getType() == Double.class) {                            cv.put(StringUtils.upTo_(field.getName()), Double.valueOf(((Number)field.get(data)).doubleValue()));                        } else {                            throw new SqlException(data.getClass().getName() + "->" + field.getName() + " type is not supported by database");                        }                    }                }            }        } catch (IllegalAccessException e) {        } catch (IllegalArgumentException e) {        }        return (int) database.insert(StringUtils.upTo_(data.getClass().getSimpleName()), null, cv);    }    /**     * delete a row by primary key.     *     * @param mainKey     * @return     * @throws SqlException     */    @Override    public int deleteData(int mainKey) throws SqlException {        // execute        int ret = database.delete(StringUtils.upTo_(dataClass.getSimpleName()), "id = ?", new String[]{String.valueOf(mainKey)});        return ret;    }    /**     * delete all rows from the table.     */    public void deleteAll() {        database.delete(StringUtils.upTo_(dataClass.getSimpleName()), null, null);    }    /**     * delete some rows by custom selection.     * @param selection     * @throws SqlException     */    @Override    public void deleteDataCustom(String selection) throws SqlException {        database.execSQL("delete from " + StringUtils.upTo_(dataClass.getSimpleName()) + (selection != null ? ( " where " + selection ) : ""));    }    /**     * Modify a row by id, which means modify a selected row.     * If the column is null, the column will be set to null, whether it is null or not before.     * @param data a row data     * @return rows affected.     * @throws SqlException If the id is not set or some column's type is invalid, the exception will be thrown.     */    @Override    public int modifyData(T data) throws SqlException {        ContentValues cv = new ContentValues();        Field[] fields = data.getClass().getDeclaredFields();        int mainKey = -1;        try {            for(Field field : fields) {                Column column = field.getAnnotation(Column.class);                if(column != null) {                    field.setAccessible(true);                    if(field.get(data) == null) {                        cv.putNull(StringUtils.upTo_(field.getName()));                    } else {                        if(field.getType() == Integer.class || field.getType() == Short.class || field.getType() == Long.class) {                            cv.put(StringUtils.upTo_(field.getName()), Long.valueOf(((Number)field.get(data)).longValue()));                        } else if(field.getType() == String.class) {                            cv.put(StringUtils.upTo_(field.getName()), (String)field.get(data));                        } else if(field.getType() == byte[].class) {                            cv.put(StringUtils.upTo_(field.getName()), (byte[])field.get(data));                        } else if(field.getType() == Float.class || field.getType() == Double.class) {                            cv.put(StringUtils.upTo_(field.getName()), Double.valueOf(((Number)field.get(data)).doubleValue()));                        } else {                            throw new SqlException(data.getClass().getName() + "->" + field.getName() + " type is not supported by database");                        }                    }                }            }            Field field = TableEntity.class.getDeclaredField("id");            mainKey = (int) field.get(data);        } catch (IllegalAccessException e) {        } catch (IllegalArgumentException e) {        } catch (NoSuchFieldException e) {            e.printStackTrace();        }        if(mainKey == -1) {            throw new SqlException("the row id is not set yet!");        }        int ret = database.update(StringUtils.upTo_(data.getClass().getSimpleName()), cv, "id = ?", new String[]{String.valueOf(mainKey)});        return ret;    }    /**     * Modify a row by id, which means modify a selected row.     * If the column is null, the column will not be set to any value and it will keep its original value.     * @param data a row data     * @return rows affected.     * @throws SqlException If the id is not set or some column's type is invalid, the exception will be thrown.     */    @Override    public int modifyDataSelected(T data) throws SqlException {        ContentValues cv = new ContentValues();        Field[] fields = data.getClass().getDeclaredFields();        int mainKey = -1;        try {            for(Field field : fields) {                Column column = field.getAnnotation(Column.class);                if(column != null) {                    field.setAccessible(true);                    if(field.get(data) != null) {                        if(field.getType() == Integer.class || field.getType() == Short.class || field.getType() == Long.class) {                            cv.put(StringUtils.upTo_(field.getName()), Long.valueOf(((Number)field.get(data)).longValue()));                        } else if(field.getType() == String.class) {                            cv.put(StringUtils.upTo_(field.getName()), (String)field.get(data));                        } else if(field.getType() == byte[].class) {                            cv.put(StringUtils.upTo_(field.getName()), (byte[])field.get(data));                        } else if(field.getType() == Float.class || field.getType() == Double.class) {                            cv.put(StringUtils.upTo_(field.getName()), Double.valueOf(((Number)field.get(data)).doubleValue()));                        } else {                            throw new SqlException(data.getClass().getName() + "->" + field.getName() + " type is not supported by database");                        }                    }                }            }            Field field = TableEntity.class.getDeclaredField("id");            mainKey = (int) field.get(data);        } catch (IllegalAccessException e) {        } catch (IllegalArgumentException e) {        } catch (NoSuchFieldException e) {            e.printStackTrace();        }        if(mainKey == -1) {            throw new SqlException("the row id is not set yet!");        }        int ret = database.update(StringUtils.upTo_(data.getClass().getSimpleName()), cv, "id = ?", new String[]{String.valueOf(mainKey)});        return ret;    }    /**     *     * Modify a row by custom selection, and the id will not be modified any time.     * If the column is null, the column will not be set to any value and it will keep its original value.     * @param data a row data     * @return rows affected.     * @throws SqlException If the id is not set or some column's type is invalid, the exception will be thrown.     */    @Override    public int modifyDataSelectedCustom(T data, String selection) throws SqlException {        ContentValues cv = new ContentValues();        Field[] fields = data.getClass().getDeclaredFields();        String mainKeyField = null;        int mainKey = -1;        try {            for(Field field : fields) {                Column column = field.getAnnotation(Column.class);                if(column != null) {                    field.setAccessible(true);                    if(!field.getName().equals("id")) {                        // id will not be modified;                        if(field.get(data) != null) {                            if(field.getType() == Integer.class || field.getType() == Short.class || field.getType() == Long.class) {                                cv.put(StringUtils.upTo_(field.getName()), Long.valueOf(((Number)field.get(data)).longValue()));                            } else if(field.getType() == String.class) {                                cv.put(StringUtils.upTo_(field.getName()), (String)field.get(data));                            } else if(field.getType() == byte[].class) {                                cv.put(StringUtils.upTo_(field.getName()), (byte[])field.get(data));                            } else if(field.getType() == Float.class || field.getType() == Double.class) {                                cv.put(StringUtils.upTo_(field.getName()), Double.valueOf(((Number)field.get(data)).doubleValue()));                            } else {                                throw new SqlException(data.getClass().getName() + "->" + field.getName() + " type is not supported by database");                            }                        }                    }                }            }        } catch (IllegalAccessException e) {        } catch (IllegalArgumentException e) {        }        int ret = database.update(StringUtils.upTo_(data.getClass().getSimpleName()), cv, selection, null);        return ret;    }    /**     * Query a row by id.     * @param mainKey     * @return the selected data, it won't be null.     * @throws SqlException If the row is not found, the exception will be thrown.     */    @Override    public T queryDataById(int mainKey) throws SqlException {        Cursor cursor = database.query(StringUtils.upTo_(dataClass.getSimpleName()), new String[]{"*"}, "id = ? ", new String[]{String.valueOf(mainKey)}, null, null, null);        if(cursor == null || cursor.getCount() != 1) {            throw new SqlException("the row can not be found");        }        try {            return cursorToDataList(cursor).get(0);        } finally {            cursor.close();        }    }    /**     * Query all rows from the table.     * @return the list of datas, the list can be empty, but it won't be null.     */    @Override    public List<T> queryAllData() {        Cursor cursor = database.query(StringUtils.upTo_(dataClass.getSimpleName()), new String[]{"*"}, null, null, null, null, null);        try {            return cursorToDataList(cursor);        } finally {            cursor.close();        }    }    /**     * Query some rows by custom selection.     * @param selection     * @return the list of datas, the list can be empty, but it won't be null.     */    public List<T> queryDataCustom(String selection) {        Cursor cursor = database.rawQuery("select * from " + StringUtils.upTo_(dataClass.getSimpleName()) + selection, null);        try {            return cursorToDataList(cursor);        } finally {            cursor.close();        }    }    @Override    public long countBySelection(String selection) throws SqlException {        Cursor cursor = database.rawQuery("select count(*) from " + StringUtils.upTo_(dataClass.getSimpleName()) + (selection != null ? ( " where " + selection ) : ""), null);        cursor.moveToFirst();        int count = cursor.getInt(0);        cursor.close();        return count;    }    @Override    public SQLiteDatabase getDb() {        if(database == null) {            database = getDatabase(listener);        }        return database;    }    @SuppressWarnings("unchecked")    private List<T> cursorToDataList(Cursor cursor){        List<T> list = new ArrayList<T>();        if(cursor != null) {            cursor.moveToFirst();            if(cursor.getCount() == 0) {                return list;            }            do{                try {                    T data = (T) dataClass.newInstance();                    String[] columns = cursor.getColumnNames();                    for(String column : columns) {                        Field field;                        if(column.equals("id")) {                            field = TableEntity.class.getDeclaredField("id");                        } else {                            field = data.getClass().getDeclaredField(StringUtils._ToUp(column, false));                        }                        field.setAccessible(true);                        int i = cursor.getColumnIndex(column);                        int type = cursor.getType(i);                        switch (type) {                            case Cursor.FIELD_TYPE_INTEGER:                                if(field.getType() == Integer.class) {                                    field.set(data, cursor.getInt(cursor.getColumnIndex(column)));                                } else if(field.getType() == Short.class) {                                    field.set(data, cursor.getShort(cursor.getColumnIndex(column)));                                } else if(field.getType() == Long.class) {                                    field.set(data, cursor.getLong(cursor.getColumnIndex(column)));                                }                                break;                            case Cursor.FIELD_TYPE_BLOB:                                field.set(data, cursor.getBlob(cursor.getColumnIndex(column)));                                break;                            case Cursor.FIELD_TYPE_FLOAT:                                if(field.getType() == Float.class || field.getType() == float.class) {                                    field.set(data, cursor.getFloat(cursor.getColumnIndex(column)));                                } else if(field.getType() == Double.class || field.getType() == double.class) {                                    field.set(data, cursor.getDouble(cursor.getColumnIndex(column)));                                }                                break;                            case Cursor.FIELD_TYPE_STRING:                                field.set(data, cursor.getString(cursor.getColumnIndex(column)));                                break;                            case Cursor.FIELD_TYPE_NULL:                                break;                        }                    }                    list.add(data);                } catch (InstantiationException e) {                    e.printStackTrace();                } catch (IllegalAccessException e) {                    e.printStackTrace();                } catch (NoSuchFieldException e) {                    e.printStackTrace();                }            }while(cursor.moveToNext());        }        return list;    }    /**     *     * @return     * @throws SqlException     */    private SQLiteDatabase getDatabase(OnDatabaseUpdateListener listener) throws SqlException {        Config.DB_CONIFG dbConifg = Config.findDatabase(dataClass.getName(), context);        if(dbConifg == null) {            throw new SqlException("database definition not found in db_config.xml");        }        File file = context.getDatabasePath(dbConifg.DB_NAME);        // 如果数据库不存在，则先创建数据库        if(!file.getParentFile().exists()) {            file.getParentFile().mkdirs();        }        if(!file.exists()) {            try {                file.createNewFile();            } catch (IOException e) {                e.printStackTrace();            }        }        SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(file, null);        if(db.getVersion() != dbConifg.DB_VERSION) {            // database exists, and need to be updated, so we update it, and cancel creating.            if(listener != null) {                listener.onUpdate(dbConifg, db, this);                db.setVersion(dbConifg.DB_VERSION);                return db;            }        }        for(Class<? extends TableEntity> clazz : dbConifg.tableList) {            createTable(db, clazz);        }        return db;    }    /**     * 根据数据模型创建新表     * @param db     * @param dataClass 指定的数据模型     */    private void createTable(SQLiteDatabase db, Class<? extends TableEntity> dataClass) {        // 组建建表SQL语句        StringBuilder newTableSql = new StringBuilder("create table if not exists " + StringUtils.upTo_(dataClass.getSimpleName())).append(" (`id` integer primary key autoincrement, ");        Field[] fields = dataClass.getDeclaredFields();        for(Field field : fields) {            Column column = field.getAnnotation(Column.class);            if(column != null) {                newTableSql.append("`" + StringUtils.upTo_(field.getName()) + "` ");                if(field.getType() == Integer.class || field.getType() == Short.class || field.getType() == Long.class) {                    newTableSql.append("int ");                } else if(field.getType() == String.class) {                    newTableSql.append("text ");                } else if(field.getType() == byte[].class) {                    newTableSql.append("blob ");                } else if(field.getType() == Float.class || field.getType() == Double.class) {                    newTableSql.append("real ");                } else {                    throw new SqlException(dataClass.getName() + "->" + field.getName() + " type is not supported by database");                }                if(field.getName().equals("id")) {                    newTableSql.append("primary key ");                }                if(!column.nullable() && !field.getName().equals("id")) {                    newTableSql.append("not null ");                }                if(column.unique() && !field.getName().equals("id")) {                    newTableSql.append("unique ");                }                newTableSql.append(", ");            }        }        newTableSql.delete(newTableSql.length() - 2, newTableSql.length());        newTableSql.append(")");        // 建表        db.execSQL(newTableSql.toString());    }    /**     * when all the tasks is done, don't forget to do this.     * @throws SqlException     */    @Override    public void closeDb() throws SqlException {        if(database != null) {            database.close();            database = null;        }    }    /**     * delete this table from the database.     * @param database     * @throws SqlException     */    @Override    public void dropTable(SQLiteDatabase database) throws SqlException {        database.execSQL("drop table " + StringUtils.upTo_(dataClass.getSimpleName()));    }    /**     * update table rules:     * <ol>     * <li>将所有表用“表名”+“_temp”的方式重命名.</li>     * <li>按照更新后的数据模型重新创建所有的表，并且从被重命名的原表中拷贝数据     * <div>	 * 拷贝规则：	 * <ul>	 * <li>字段无变化，则直接拷贝该字段</li>	 * <li>字段是新添加的，执行{@link ColumnTypeConverter#onConvert(Integer, String, Class, Object)}获取待拷贝进新表的新值</li>	 * <li>字段是重命名的，先执行{@link ColumnTypeConverter#onCheckUpdateType(String, Class)}获取原字段名称，再从原表中取出数据</li>	 * <li>如果字段类型发生变化，不管字段名称有没有改变，都要调用{@link ColumnTypeConverter#onConvert(Integer, String, Class, Object)}获取待拷贝进新表的新值</li>	 * <li>如果字段非空约束或唯一性约束发生改变，而字段内容是空值，此时也会调用{@link ColumnTypeConverter#onConvert(Integer, String, Class, Object)}获取非空新值</li>	 * </ul>     * </div>     * </li>     * <li>删除原表数据</li>     * </ol>     * @throws SqlException     */    @Override    public void onUpdateTable(Config.DB_CONIFG dbConfig, SQLiteDatabase database, ColumnTypeConverter converter) throws SqlException {        // step 1: rename        for(Class<? extends TableEntity> tableClass : dbConfig.tableList) {            String tableName = StringUtils.upTo_(tableClass.getSimpleName());            database.execSQL("alter table " + tableName + " rename to " + tableName + "_temp");        }        // step 2: create and copy        // detail step 1: create        for (Class<? extends TableEntity> tableClass : dbConfig.tableList) {            createTable(database, tableClass);        }        // detail step 2: copy        for (Class<? extends TableEntity> tableClass : dbConfig.tableList) {            String tableName = StringUtils.upTo_(tableClass.getSimpleName());            Cursor cursor = database.query(tableName + "_temp", new String[]{"*"}, null, null, null, null, null);            Field[] fields = tableClass.getDeclaredFields();            Field[] temp = new Field[fields.length + 1];            System.arraycopy(fields, 0, temp, 0, fields.length);            try {                temp[fields.length] = TableEntity.class.getDeclaredField("id");            } catch (NoSuchFieldException e) {                e.printStackTrace();            }            fields = temp;            String[] newNames = new String[fields.length];            for(int i = 0; i < fields.length; i++) {                newNames[i] = fields[i].getName();            }            if(cursor != null) {                cursor.moveToFirst();                do{                    try {                        TableEntity data = (TableEntity) tableClass.newInstance();                        int id = cursor.getInt(cursor.getColumnIndex("id"));                        for(Field field : fields) {                            String column = StringUtils.upTo_(field.getName());                            field.setAccessible(true);                            int columnIndex = cursor.getColumnIndex(column);                            if(columnIndex == -1) {                                // column added or renamed.                                Object value = null;                                UpdateTypeResult updateTypeResult = converter.onCheckUpdateType(field.getName(), tableClass);                                switch (updateTypeResult.eUpdateType) {                                    case ADD_COLUMN:                                        value = converter.onConvert(id, field.getName(), tableClass, null);                                        break;                                    case MODIFY_COLUMN_NAME:                                        int originalIndex = cursor.getColumnIndex(updateTypeResult.originalColumnName);                                        if(originalIndex == -1) throw new SqlException("original column name is wrong!");                                        switch (cursor.getType(originalIndex)) {                                            case Cursor.FIELD_TYPE_INTEGER:                                                value = cursor.getLong(originalIndex);                                                break;                                            case Cursor.FIELD_TYPE_BLOB:                                                value = cursor.getBlob(originalIndex);                                                break;                                            case Cursor.FIELD_TYPE_FLOAT:                                                value = cursor.getDouble(originalIndex);                                                break;                                            case Cursor.FIELD_TYPE_STRING:                                                value = cursor.getString(originalIndex);                                                break;                                            case Cursor.FIELD_TYPE_NULL:                                                break;                                        }                                        value = converter.onConvert(id, field.getName(), tableClass, value);                                        break;                                }                                field.set(data, value);                            } else {                                Object originalValue = null;                                try {                                    switch (cursor.getType(columnIndex)) {                                        case Cursor.FIELD_TYPE_INTEGER:                                            if(field.getType() == Integer.class) {                                                field.set(data, originalValue = cursor.getInt(columnIndex));                                            } else if(field.getType() == Short.class) {                                                field.set(data, originalValue = cursor.getShort(columnIndex));                                            } else if(field.getType() == Long.class) {                                                field.set(data, originalValue = cursor.getLong(columnIndex));                                            }                                            break;                                        case Cursor.FIELD_TYPE_BLOB:                                            field.set(data, originalValue = cursor.getBlob(columnIndex));                                            break;                                        case Cursor.FIELD_TYPE_FLOAT:                                            if(field.getType() == Float.class) {                                                field.set(data, originalValue = cursor.getFloat(columnIndex));                                            } else if(field.getType() == Double.class) {                                                field.set(data, originalValue = cursor.getDouble(columnIndex));                                            }                                            break;                                        case Cursor.FIELD_TYPE_STRING:                                            field.set(data, originalValue = cursor.getString(columnIndex));                                            break;                                        case Cursor.FIELD_TYPE_NULL:                                            break;                                    }                                    if((originalValue == null && !field.getAnnotation(Column.class).nullable()) || field.getAnnotation(Column.class).unique()) {                                        // if the column is nullable or unique, send a convert request, to make sure the value is right.                                        field.set(data, converter.onConvert(id, field.getName(), tableClass, originalValue));                                    } else {                                        field.set(data, originalValue);                                    }                                } catch (IllegalArgumentException e) {                                    field.set(data, converter.onConvert(id, field.getName(), tableClass, originalValue));                                }                            }                        }                        ContentValues cv = new ContentValues();                        for(Field field : fields) {                            Column column = field.getAnnotation(Column.class);                            if(column != null) {                                field.setAccessible(true);                                if(field.get(data) == null) {                                    if(!field.getName().equals("id")) {                                        if(!column.nullable()) {                                            throw new SqlException(tableClass.getName() + " -> " + field.getName() + " can not be null");                                        }                                        cv.putNull(StringUtils.upTo_(field.getName()));                                    }                                } else {                                    if(field.getType() == Integer.class || field.getType() == Short.class || field.getType() == Long.class) {                                        cv.put(StringUtils.upTo_(field.getName()), Long.valueOf(((Number)field.get(data)).longValue()));                                    } else if(field.getType() == String.class) {                                        cv.put(StringUtils.upTo_(field.getName()), (String)field.get(data));                                    } else if(field.getType() == byte[].class) {                                        cv.put(StringUtils.upTo_(field.getName()), (byte[])field.get(data));                                    } else if(field.getType() == Float.class || field.getType() == Double.class) {                                        cv.put(StringUtils.upTo_(field.getName()), Double.valueOf(((Number)field.get(data)).doubleValue()));                                    } else {                                        throw new SqlException(data.getClass().getName() + "->" + field.getName() + " type is not supported by database");                                    }                                }                            }                        }                        database.insert(StringUtils.upTo_(data.getClass().getSimpleName()), null, cv);                    } catch (InstantiationException e) {                        e.printStackTrace();                    } catch (IllegalAccessException e) {                        e.printStackTrace();                    }                }while(cursor.moveToNext());            }        }        // step 3: drop        for(Class<? extends TableEntity> tableClass : dbConfig.tableList) {            String tableName = StringUtils.upTo_(tableClass.getSimpleName());            database.execSQL("drop table " + tableName + "_temp");        }    }    /**     * 字段更新回调接口，当调用{@link Dao#onUpdateTable(me.jerry.framework.db.Config.DB_CONIFG, SQLiteDatabase, ColumnTypeConverter)}时，     * 开发者需实现该接口提供具体的数据库字段更新信息     */    public static interface ColumnTypeConverter {        /**         * 执行数据库更新时，发现有新添加或更改字段名的字段时会调用该回调接口，来区分当前是新添加字段还是更改字段名，更改字段名需提供原字段名称         * @param newColumnName 新字段名称         * @param tableClass 数据表对应的数据类型         * @return 数据更新类型（新增或改字段名）         */        public UpdateTypeResult onCheckUpdateType(String newColumnName, Class<? extends TableEntity> tableClass);        /**         * 执行数据库更新时，有新增字段，更改字段名，修改字段类型等数据库框架无法获取数据值的情况时，调用该回调接口，如果是更改字段名或修改字段名称会有原数据库表中的值传入         * @param id 数据记录的id         * @param newColumnName 新字段名称         * @param tableClass 数据表对应的数据类型         * @param oldValue 原数据库中的数据，待转换的数据，如果是新增字段，该参数为null，需开发者提供默认值         * @return 返回转换后结果，无需转换的时候返回oldValue，不能返回null         */        public Object onConvert(Integer id, String newColumnName, Class<? extends TableEntity> tableClass, Object oldValue);    }    /**     * 更新类型     * @author JerryGeng     */    public static class UpdateTypeResult {    	/**    	 * 更新类型    	 */        public final EUpdateType eUpdateType;        /**         * 如果是修改字段名，这里表示原字段名称         */        public final String originalColumnName;        /**         * 更新类型（新增和重命名两种）         * @author JerryGeng         *         */        public static enum EUpdateType {            ADD_COLUMN,            MODIFY_COLUMN_NAME,            ;        }        public UpdateTypeResult(EUpdateType eUpdateType, String originalColumnName) {            this.originalColumnName = originalColumnName;            this.eUpdateType = eUpdateType;        }    }}